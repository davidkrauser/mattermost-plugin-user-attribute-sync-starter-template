package sync

import (
	"errors"
	"testing"

	"github.com/mattermost/mattermost/server/public/model"
	"github.com/mattermost/mattermost/server/public/plugin/plugintest"
	"github.com/mattermost/mattermost/server/public/pluginapi"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestSyncFields(t *testing.T) {
	groupID := "test-group-id"

	t.Run("creates all fields and returns ID cache", func(t *testing.T) {
		api := &plugintest.API{}
		client := pluginapi.NewClient(api, &plugintest.Driver{})

		// Mock GetPropertyFieldByName returning not found (fields don't exist yet)
		api.On("GetPropertyFieldByName", groupID, "", "Job Title").Return(nil, errors.New("not found")).Once()
		api.On("GetPropertyFieldByName", groupID, "", "Programs").Return(nil, errors.New("not found")).Once()
		api.On("GetPropertyFieldByName", groupID, "", "Start Date").Return(nil, errors.New("not found")).Once()

		// Mock field creation - ID is generated by Mattermost
		api.On("CreatePropertyField", mock.MatchedBy(func(f *model.PropertyField) bool {
			return f.Name == "Job Title" && f.ID == ""
		})).Return(&model.PropertyField{ID: "generated_id_1", Name: "Job Title", Type: model.PropertyFieldTypeText}, nil)

		programsField := &model.PropertyField{
			ID:   "generated_id_2",
			Name: "Programs",
			Type: model.PropertyFieldTypeMultiselect,
			Attrs: model.StringInterface{
				model.PropertyFieldAttributeOptions: []interface{}{
					map[string]interface{}{"id": "opt_id_1", "name": "Apples"},
					map[string]interface{}{"id": "opt_id_2", "name": "Oranges"},
					map[string]interface{}{"id": "opt_id_3", "name": "Lemons"},
				},
			},
		}
		api.On("CreatePropertyField", mock.MatchedBy(func(f *model.PropertyField) bool {
			return f.Name == "Programs" && f.ID == ""
		})).Return(programsField, nil)

		// Mock GetPropertyField to return the Programs field with options (for option ID extraction)
		api.On("GetPropertyField", groupID, "generated_id_2").Return(programsField, nil).Once()

		api.On("CreatePropertyField", mock.MatchedBy(func(f *model.PropertyField) bool {
			return f.Name == "Start Date" && f.ID == ""
		})).Return(&model.PropertyField{ID: "generated_id_3", Name: "Start Date", Type: model.PropertyFieldTypeDate}, nil)

		// Mock logging
		api.On("LogInfo", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Maybe()
		api.On("LogDebug", mock.Anything, mock.Anything, mock.Anything).Maybe()

		cache, err := SyncFields(client, groupID)

		require.NoError(t, err)
		require.NotNil(t, cache)
		assert.Equal(t, "generated_id_1", cache.GetFieldID("job_title"))
		assert.Equal(t, "generated_id_2", cache.GetFieldID("programs"))
		assert.Equal(t, "generated_id_3", cache.GetFieldID("start_date"))
		assert.Equal(t, "opt_id_1", cache.GetProgramOptionID("Apples"))
		assert.Equal(t, "opt_id_2", cache.GetProgramOptionID("Oranges"))
		assert.Equal(t, "opt_id_3", cache.GetProgramOptionID("Lemons"))
		api.AssertExpectations(t)
	})

	t.Run("updates existing fields", func(t *testing.T) {
		api := &plugintest.API{}
		client := pluginapi.NewClient(api, &plugintest.Driver{})

		// Mock GetPropertyFieldByName for each field (simulating they exist)
		existingJobTitle := &model.PropertyField{
			ID:      "existing_id_1",
			GroupID: groupID,
			Name:    "Job Title",
			Type:    model.PropertyFieldTypeText,
			Attrs:   make(model.StringInterface),
		}
		api.On("GetPropertyFieldByName", groupID, "", "Job Title").Return(existingJobTitle, nil).Once()
		api.On("UpdatePropertyField", groupID, mock.MatchedBy(func(f *model.PropertyField) bool {
			return f.ID == "existing_id_1"
		})).Return(existingJobTitle, nil).Once()

		existingPrograms := &model.PropertyField{
			ID:      "existing_id_2",
			GroupID: groupID,
			Name:    "Programs",
			Type:    model.PropertyFieldTypeMultiselect,
			Attrs: model.StringInterface{
				model.PropertyFieldAttributeOptions: []interface{}{
					map[string]interface{}{"id": "opt_id_1", "name": "Apples"},
					map[string]interface{}{"id": "opt_id_2", "name": "Oranges"},
					map[string]interface{}{"id": "opt_id_3", "name": "Lemons"},
				},
			},
		}
		api.On("GetPropertyFieldByName", groupID, "", "Programs").Return(existingPrograms, nil).Once()
		api.On("UpdatePropertyField", groupID, mock.MatchedBy(func(f *model.PropertyField) bool {
			return f.ID == "existing_id_2"
		})).Return(existingPrograms, nil).Once()
		api.On("GetPropertyField", groupID, "existing_id_2").Return(existingPrograms, nil).Once()

		existingStartDate := &model.PropertyField{
			ID:      "existing_id_3",
			GroupID: groupID,
			Name:    "Start Date",
			Type:    model.PropertyFieldTypeDate,
			Attrs:   make(model.StringInterface),
		}
		api.On("GetPropertyFieldByName", groupID, "", "Start Date").Return(existingStartDate, nil).Once()
		api.On("UpdatePropertyField", groupID, mock.MatchedBy(func(f *model.PropertyField) bool {
			return f.ID == "existing_id_3"
		})).Return(existingStartDate, nil).Once()

		// Mock logging
		api.On("LogInfo", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Maybe()
		api.On("LogDebug", mock.Anything, mock.Anything, mock.Anything).Maybe()

		cache, err := SyncFields(client, groupID)

		require.NoError(t, err)
		require.NotNil(t, cache)
		assert.Equal(t, "existing_id_1", cache.GetFieldID("job_title"))
		assert.Equal(t, "existing_id_2", cache.GetFieldID("programs"))
		assert.Equal(t, "existing_id_3", cache.GetFieldID("start_date"))
		api.AssertExpectations(t)
	})

	t.Run("multiselect field includes options", func(t *testing.T) {
		api := &plugintest.API{}
		client := pluginapi.NewClient(api, &plugintest.Driver{})

		// Mock GetPropertyFieldByName returning not found for all fields
		api.On("GetPropertyFieldByName", groupID, "", mock.Anything).Return(nil, errors.New("not found"))

		// Mock field creation - verify Programs field has options
		optionsVerified := false
		api.On("CreatePropertyField", mock.MatchedBy(func(f *model.PropertyField) bool {
			if f.Name == "Programs" {
				// Verify Programs field has correct options
				options, ok := f.Attrs[model.PropertyFieldAttributeOptions].([]interface{})
				if ok && len(options) == 3 {
					optionsVerified = true
				}
			}
			return true
		})).Return(func(f *model.PropertyField) (*model.PropertyField, error) {
			// Return field with generated ID
			f.ID = "gen_id_" + f.Name
			if f.Name == "Programs" {
				f.Attrs[model.PropertyFieldAttributeOptions] = []interface{}{
					map[string]interface{}{"id": "opt1", "name": "Apples"},
					map[string]interface{}{"id": "opt2", "name": "Oranges"},
					map[string]interface{}{"id": "opt3", "name": "Lemons"},
				}
			}
			return f, nil
		})

		// Mock GetPropertyField for Programs field (for option extraction)
		api.On("GetPropertyField", groupID, "gen_id_Programs").Return(&model.PropertyField{
			ID: "gen_id_Programs",
			Attrs: model.StringInterface{
				model.PropertyFieldAttributeOptions: []interface{}{
					map[string]interface{}{"id": "opt1", "name": "Apples"},
					map[string]interface{}{"id": "opt2", "name": "Oranges"},
					map[string]interface{}{"id": "opt3", "name": "Lemons"},
				},
			},
		}, nil).Maybe()

		// Mock logging
		api.On("LogInfo", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Maybe()
		api.On("LogDebug", mock.Anything, mock.Anything, mock.Anything).Maybe()

		cache, err := SyncFields(client, groupID)

		require.NoError(t, err)
		assert.True(t, optionsVerified, "Options should be verified during field creation")
		assert.NotNil(t, cache)
	})

	t.Run("continues on partial failures", func(t *testing.T) {
		api := &plugintest.API{}
		client := pluginapi.NewClient(api, &plugintest.Driver{})

		// Mock GetPropertyFieldByName - all fields don't exist
		api.On("GetPropertyFieldByName", groupID, "", mock.Anything).Return(nil, errors.New("not found"))

		createCallCount := 0
		// First field creation fails, others succeed
		api.On("CreatePropertyField", mock.Anything).Return(func(f *model.PropertyField) (*model.PropertyField, error) {
			createCallCount++
			if createCallCount == 1 {
				// First call fails
				return nil, errors.New("API error")
			}
			// Subsequent calls succeed
			f.ID = "generated_id_" + f.Name
			if f.Name == "Programs" {
				f.Attrs[model.PropertyFieldAttributeOptions] = []interface{}{
					map[string]interface{}{"id": "opt1", "name": "Apples"},
				}
			}
			return f, nil
		})

		// Mock GetPropertyField for Programs field
		api.On("GetPropertyField", groupID, mock.Anything).Return(&model.PropertyField{
			ID: "generated_id_Programs",
			Attrs: model.StringInterface{
				model.PropertyFieldAttributeOptions: []interface{}{
					map[string]interface{}{"id": "opt1", "name": "Apples"},
				},
			},
		}, nil).Maybe()

		// Mock logging
		api.On("LogInfo", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Maybe()
		api.On("LogError", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Maybe()
		api.On("LogWarn", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Maybe()
		api.On("LogDebug", mock.Anything, mock.Anything, mock.Anything).Maybe()

		cache, err := SyncFields(client, groupID)

		// Should not return error (graceful degradation)
		require.NoError(t, err)
		require.NotNil(t, cache)
	})
}

func TestFieldIDCache(t *testing.T) {
	t.Run("GetFieldID returns correct field IDs", func(t *testing.T) {
		cache := &FieldIDCache{
			FieldNameToID: map[string]string{
				"job_title":  "id1",
				"programs":   "id2",
				"start_date": "id3",
			},
		}
		assert.Equal(t, "id1", cache.GetFieldID("job_title"))
		assert.Equal(t, "id2", cache.GetFieldID("programs"))
		assert.Equal(t, "id3", cache.GetFieldID("start_date"))
	})

	t.Run("GetFieldID returns empty string for unknown field", func(t *testing.T) {
		cache := &FieldIDCache{
			FieldNameToID: make(map[string]string),
		}
		assert.Equal(t, "", cache.GetFieldID("unknown_field"))
	})

	t.Run("GetProgramOptionID returns correct option IDs", func(t *testing.T) {
		cache := &FieldIDCache{
			ProgramOptionNameToID: map[string]string{
				"Apples":  "opt1",
				"Oranges": "opt2",
				"Lemons":  "opt3",
			},
		}
		assert.Equal(t, "opt1", cache.GetProgramOptionID("Apples"))
		assert.Equal(t, "opt2", cache.GetProgramOptionID("Oranges"))
		assert.Equal(t, "opt3", cache.GetProgramOptionID("Lemons"))
	})

	t.Run("GetProgramOptionID returns empty string for unknown option", func(t *testing.T) {
		cache := &FieldIDCache{
			ProgramOptionNameToID: make(map[string]string),
		}
		assert.Equal(t, "", cache.GetProgramOptionID("Unknown"))
	})
}
